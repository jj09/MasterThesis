%!TEX root = etdrtemplate.tex

\cleardoublepage


\chapter{AADL/BLESS to SPARK Ada translation}
\label{codegen}

First step was to create mock (based on doc, aadl models and implemented PCA Pump).
Prototyping Embedded Systems using AADL lasts for a few years \cite{PrototypyingAadl:Paper}.



\section{AADL/BLESS to SPARK Ada mapping}
\label{codegen:mapping}

%https://wiki.sei.cmu.edu/aadl/images/4/40/13_04_24-AADL-Code_Generation.pdf

%https://wiki.sei.cmu.edu/aadl/images/7/73/AADLV2Overview-AADLUserDay-Feb_2010.pdf (slide 35: port connections)

Mapping is driven by "Architecture analysis \& Design Language (AADL) V2 Programming Language Annex Document" \cite{AnnexDoc}. This document was discussed during AADL User Days in Valencia (February 2013)\footnote{http://www.aadl.info/aadl/downloads/committee/feb2013/presentations/13\_02\_04-AADL-Code\%20Generation.pdf} and in Jacksonville, FL (April 2013)\footnote{https://wiki.sei.cmu.edu/aadl/images/8/8a/Constraint\_Annex\_April22.v3.pdf}. Ocarina tool suite (based on older AADL annex documents \cite{Ocarina:Article}) and its examples\footnote{https://github.com/yoogx/polyorb-hi-ada/tree/master/examples/aadlv2} was also helpful in understanding of AADL to Ada translation.
Only high level mapping is done. No implementation (thread interactions) like Ocarina does. 


\subsection{Data types mapping}
\label{codegen:mapping:data}

[TABLE WITH TYPES MAPPING - when types mapping will be done]

During AADL/BLESS to SPARK Ada types mapping, SPARK Examiner was helpful. It detected redundancy in enumerators. Both \lstinline{Alarm_Type} and \lstinline{Warning_Type} contained \lstinline{No_Alarm} enumerators, which was a bug. \lstinline{Warning_Type} should have \lstinline{No_Warning} enumerator instead.


\subsection{AADL ports mapping}
\label{codegen:mapping:ports}

Proposed ports mapping shown in table \ref{table:aadl2spark_ports} is based on AADL runtime services from Annex 2 to "Programming Language Annex Document" \cite{AnnexDoc}. Additionaly, the mapping contains SPARK 2005 contracts.

% maybe split right column into 2 rows: spec and body?
\singlespacing
\begin{center}
	\begin{longtable}{| p{2in} | p{4in} |}
	
		\caption{AADL to SPARK ports mapping.}
		\label{table:aadl2spark_ports}
		\\
		\hline
		\multicolumn{1}{|c|}{\textbf{AADL/BLESS}} & \multicolumn{1}{|c|}{\textbf{SPARK Ada}} \\ \hline
		\endfirsthead

		\multicolumn{2}{c}%
		{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
		\hline 
		\multicolumn{1}{|c|}{\textbf{AADL/BLESS}} & \multicolumn{1}{|c|}{\textbf{SPARK Ada}} \\ \hline
		\endhead

		\hline \multicolumn{2}{|r|}{{Continued on next page}} \\ \hline
		\endfoot

		\hline %\hline
		\endlastfoot

		\begin{lstlisting}[language=aadl]
			Port_Name : 
				in data port Port_Type;
		\end{lstlisting} 
		&
		\begin{lstlisting}[language=ada]
			-- spec (.ads):
			procedure Receive_Port_Name;
			--# global out Port_Name;

			-- body (.adb):
			Port_Name : Port_Type;

			procedure Receive_Port_Name 
			is
			begin
				-- TODO: implement receiving Port_Name value
				-- e.g.:
				-- Port_Name := Some_Pkg.Get_Port_Name;
			end Receive_Port_Name;
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=aadl]
			Port_Name : 
				out data port Port_Type;
		\end{lstlisting} 
		&
		\begin{lstlisting}[language=ada]
			-- spec (.ads)
			function Get_Port_Name return Port_Type;
			--# global in Port_Name;

			-- body (.adb):
			Port_Name : Port_Type;

			function Get_Port_Name return Port_Type 
			is
			begin
				return Port_Name;
			end Get_Port_Name;
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=aadl]
			Port_Name : 
				in event port;
		\end{lstlisting} 
		&
		\begin{lstlisting}[language=ada]
			-- spec (.ads)
			procedure Put_Port_Name;

			-- body (.adb):
			procedure Put_Port_Name 
			is
			begin
				-- TODO: implement event handler
			end Put_Port_Name;
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=aadl]
			Port_Name : 
				out event port;
		\end{lstlisting} 
		&
		\begin{lstlisting}[language=ada]
			-- spec (.ads)
			procedure Send_Port_Name;

			-- body (.adb):

			procedure Send_Port_Name 
			is
			begin
				-- TODO: implement receiving Port_Name value
				-- e.g.:
				-- Some_Pkg.Put_Port_Name;
			end Send_Port_Name;
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=aadl]
			Port_Name : 
				in event data port Port_Type;
		\end{lstlisting} 
		&
		\begin{lstlisting}[language=ada]
			-- spec (.ads)
			procedure Put_Port_Name(Port_Name_In : Port_Type);
			--# global out Port_Name;
			--# derives Port_Name from Port_Name_In;

			-- body (.adb):
			Port_Name : Port_Type;

			procedure Put_Port_Name (Port_Name_In : Port_Type) 
			is
			begin
				Port_Name := Port_Name_In;
			end Put_Port_Name;
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=aadl]
			Port_Name : 
				out event data port Port_Type;
		\end{lstlisting} 
		&
		\begin{lstlisting}[language=ada]
			-- spec (.ads)
			procedure Send_Port_Name;
    		--# global in Port_Name;

			-- body (.adb):
			Port_Name : Port_Type;

			procedure Send_Port_Name 
			is
			begin
				-- TODO: implement receiving Port_Name value
				-- e.g.:
				-- Some_Pkg.Put_Port_Name(Port_Name);
			end Send_Port_Name;
		\end{lstlisting} 
	\end{longtable}
\end{center}
\doublespacing

There is a problem: "consumer.ads:1:13: Semantic Error 135 - The package Producer is undeclared or not visible, or there is a circularity in the list of inherited packages.".


\subsection{Thread to task mapping}
\label{codegen:mapping:threads}

AADL Threads are mapped into SPARK Ada tasks according to table \ref{table:threads2tasks}.

\singlespacing
\begin{table}[!ht]
	\caption{AADL threads to SPARK Ada tasks mapping.}
	\label{table:threads2tasks}
	\centering
  	\begin{tabular}{ | p{3.5in} | p{2.5in} |}
	  	%\multicolumn{1}{c}{\textbf{AADL/BLESS}} & \textbf{SPARK Ada}\\

		\hline
		\multicolumn{1}{|c|}{\textbf{AADL/BLESS}} & \multicolumn{1}{|c|}{\textbf{SPARK Ada}} \\ \hline

		\begin{lstlisting}[language=aadl]
			package Some_Pkg
				thread Some_Thread
					features
						Some_Port : out data port Port_Type;
				end Some_Thread;
			end Some_Pkg;
		\end{lstlisting} 
		& 
		\begin{lstlisting}
			package Some_Pkg
			is
				task type Some_Thread
				--# global out Some_Port;
				is
					pragma Priority(10);
				end Some_Thread;
			end Some_Pkg;
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=aadl]
			package Some_Pkg
				thread Some_Thread.imp
				end Some_Thread;
			end Some_Pkg;
		\end{lstlisting} 
		& 
		\begin{lstlisting}
			package body Custom_Pkg
			is
				st : Some_Thread;

				task body Some_Thread
				is
				begin
					-- implementation
				end Some_Thread;
			end Custom_Pkg;
		\end{lstlisting} 

		\\ \hline
	\end{tabular}
\end{table}
\doublespacing


\subsection{Subprograms mapping}
\label{codegen:mapping:subprograms}

\singlespacing
\begin{table}[!ht]
	\caption{AADL subprograms to SPARK Ada subprograms(procedures/functions) mapping.}
	\label{table:subprograms_mapping}
	\centering
  	\begin{tabular}{ | p{3in} | p{3in} |}
	  	%\multicolumn{1}{c}{\textbf{AADL/BLESS}} & \textbf{SPARK Ada}\\

		\hline
		\multicolumn{1}{|c|}{\textbf{AADL/BLESS}} & \multicolumn{1}{|c|}{\textbf{SPARK Ada}} \\ \hline

		\begin{lstlisting}[language=aadl]
			subprogram sp
			features
				e : in parameter T;
				s : out parameter T;
			end sp;
		\end{lstlisting} 
		& 
		\begin{lstlisting}
			procedure sp(e : in T; s : out T) is 
			begin
				--# implementation
			end sp;
		\end{lstlisting} 		

		\\ \hline
	\end{tabular}
\end{table}
\doublespacing


\subsection{Feature groups mapping}
\label{codegen:mapping:feature_groups}

In SPARK Ada there are nested packages and child packages. Sample nested packages are shown in listing \ref{lst:nested_packages}. Equivalent child packages are shown in listing \ref{lst:child_packages}. The name of a child package consists of the parent unit's name followed by the child package's identifier, separated by a period (dot) `.'. Calling convention is the same for child and nested packages (e.g. \lstinline{P.N} in listings \ref{lst:nested_packages} and \ref{lst:child_packages}. However, there is a difference between nested packages and child packages. In nested package declarations become visible as they are introduced, in textual order. For example, in listing \ref{lst:nested_packages} spec \lstinline{N} cannot refer to \lstinline{M} in any way. In case of child packages, with certain exceptions, all the functionality of the parent is available to a child and parent can access all its child packages. More precisely: all public and private declarations of the parent package are visible to all child packages. Private child package can be accessed only from parent's body.

\singlespacing
\begin{lstlisting}[language=ada, frame=single, gobble=0, caption={Nested packages in SPARK Ada}, label={lst:nested_packages}]
	package P is
	   D: Integer;

	   --  a nested package:
	   package N is
	      X: Integer;
	   private
	      Foo: Integer;
	   end N;

	   E: Integer;
	private
	   --  nested package in private section:
	   package M is
	      Y: Integer;
	   private
	      Bar: Integer;
	   end M;

	end P;
\end{lstlisting}
\doublespacing

\singlespacing
\begin{lstlisting}[language=ada, frame=single, gobble=0, caption={Child packages in SPARK Ada}, label={lst:child_packages}]
	package P is
	   D: Integer;
	   E: Integer;
	end P;

	--  a child package:
	package P.N is
      X: Integer;
   	private
      Foo: Integer;
	end P.N;

	--  a child private package:
	private package M is
	  Y: Integer;
	private
	  Bar: Integer;
	end M;
\end{lstlisting}
\doublespacing

There was an idea to create child package to encapsulate one feature group in it. However, SPARK Ada does not allow to access child packages private part from parent. That will require to expose feature group internal variable, which will have to be acceessible globaly. It is definitely not good solution. Thus, feature group is translated with prefix \lstinline{Feature_Group_Name_*}.



\subsection{AADL package to SPARK Ada package mapping}
\label{codegen:mapping:packages}

On listing \ref{lst:aadl_sample}, there is shown sample AADL package with system. It contains all types of ports and feature group.

\singlespacing
\begin{lstlisting}[language=aadl, frame=single, gobble=0, caption={Sample AADL package with system}, label={lst:aadl_sample}]
	package Some_Pkg
	public
	with Base_Types;

	feature group Some_Features
	features
	  Some_Out_Port: out data port Base_Types::Integer;
	  Some_In_Port: in data port Base_Types::Integer;
	end Some_Features;

	system Some_System
	features
	  Some_Feature_Group : feature group Some_Features;
	  
	  In_Data_Port : in data port Base_Types::Integer;
	  Out_Data_Port : out data port Base_Types::Integer;
	  In_Event_Port : in event port;
	  Out_Event_Port : out event port;
	  In_Event_Data_Port : in event data port Base_Types::Integer;
	  Out_Event_Data_Port : out event data port Base_Types::Integer;
	end Some_System;

	end Some_Pkg;
\end{lstlisting}
\doublespacing

Based on ports mapping, presented in section \ref{codegen:mapping:ports}, translation to SPARK Ada package is shown in listing \ref{lst:package_mapping}. 

\singlespacing
\begin{lstlisting}[language=ada, frame=single, gobble=0, caption={Translation of sample AADL package from listing \ref{lst:aadl_sample}}, label={lst:package_mapping}]
	package Some_Pkg
	--# own Some_Features_Some_Out_Port : Integer;
	--#     Some_Features_Some_In_Port : Integer;
	--#     In_Data_Port : Integer;
	--#     Out_Data_Port : Integer;
	--#     In_Event_Data_Port : Integer;
	--#     Out_Event_Data_Port : Integer;
	--# initializes Some_Features_Some_Out_Port,
	--#             Some_Features_Some_In_Port,
	--#             In_Data_Port,
	--#             Out_Data_Port,
	--#             In_Event_Data_Port,
	--#             Out_Event_Data_Port;
	is

	    function Some_Features_Get_Some_Out_Port return Integer;
	    --# global in Some_Features_Some_Out_Port;

	    procedure Some_Features_Receive_Some_In_Port;
	    --# global out Some_Features_Some_In_Port;

	    procedure Receive_In_Data_Port;
	    --# global out In_Data_Port;

	    function Get_Out_Data_Port return Integer;
	    --# global in Out_Data_Port;

	    procedure Put_In_Event_Port;

	    procedure Send_Out_Event_Port;

	    procedure Put_In_Event_Data_Port(In_Event_Data_Port_In : Integer);
	    --# global out In_Event_Data_Port;
	    --# derives In_Event_Data_Port from In_Event_Data_Port_In;

	    procedure Send_Out_Event_Data_Port;
	    --# global in Out_Event_Data_Port;

	end Some_Pkg;

	package body Some_Pkg
	is
	    Some_Features_Some_Out_Port : Integer := 0;
	    Some_Features_Some_In_Port : Integer := 0;
	    In_Data_Port : Integer := 0;
	    Out_Data_Port : Integer := 0;
	    In_Event_Data_Port : Integer := 0;
	    Out_Event_Data_Port : Integer := 0;

	    function Some_Features_Get_Some_Out_Port return Integer
	    is
	    begin
	        return Some_Features_Some_Out_Port;
	    end Some_Features_Get_Some_Out_Port;

	    procedure Some_Features_Receive_Some_In_Port
	    is
	    begin
	        -- implementation
	    end Some_Features_Receive_Some_In_Port;

	    procedure Receive_In_Data_Port
	    is
	    begin
	        -- implementation
	    end Receive_In_Data_Port;

	    function Get_Out_Data_Port return Integer
	    is
	    begin
	        return Out_Data_Port;
	    end Get_Out_Data_Port;

	    procedure Put_In_Event_Port
	    is
	    begin
	        -- implementation
	    end Put_In_Event_Port;

	    procedure Send_Out_Event_Port
	    is
	    begin
	        -- implementation
	    end Send_Out_Event_Port;

	    procedure Put_In_Event_Data_Port(In_Event_Data_Port_In : Integer)
	    is
	    begin
	        In_Event_Data_Port := In_Event_Data_Port_In;
	    end Put_In_Event_Data_Port;

	    procedure Send_Out_Event_Data_Port
	    is
	    begin
	        -- implementation
	    end Send_Out_Event_Data_Port;

	end Some_Pkg;
\end{lstlisting}
\doublespacing





\subsection{BLESS mapping}
\label{codegen:mapping:bless}

\singlespacing
\begin{center}
	\begin{longtable}{| p{3in} | p{3in} |}
		\caption{BLESS to SPARK contracts mapping.}
		\label{table:bless2spark}
		\\
		\hline
		\multicolumn{1}{|c|}{\textbf{AADL/BLESS}} & \multicolumn{1}{|c|}{\textbf{SPARK Ada}} \\ \hline
		\endfirsthead

		\multicolumn{2}{c}%
		{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
		\hline 
		\multicolumn{1}{|c|}{\textbf{AADL/BLESS}} & \multicolumn{1}{|c|}{\textbf{SPARK Ada}} \\ \hline
		\endhead

		\hline \multicolumn{2}{|r|}{{Continued on next page}} \\ \hline
		\endfoot

		\hline %\hline
		\endlastfoot

		\begin{lstlisting}[language=bless]
			BLESS::Assertion=>"<<COND1()>>"
		\end{lstlisting} 
		& 
		\begin{lstlisting}
			--# assert COND1();
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=bless]
			thread Some_Thread
			features
				Some_Port : out event port
				{BLESS:Assertion => "<<(Var1 < Var2 and COND2())>>";};
			end Some_Thread;
		\end{lstlisting} 
		& 
		\begin{lstlisting}
			task body Some_Thread
			is
			begin
				loop
					--# assert (Var1 < Var2 and COND2());
				end loop;
			end Some_Thread;
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=bless]
			thread implementation Some_Thread.imp
			annex BLESS 
			{**
				invariant <<(Some_Var < Other_Var)>>
			**};
			end Some_Thread.imp;
		\end{lstlisting} 
		& 
		\begin{lstlisting}
			task body Some_Thread
			is
			begin
				loop
					--# assert (Some_Var < Other_Var);
				end loop;
			end Some_Thread;
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=bless]
			thread implementation Some_Thread.imp
			annex BLESS 
			{**
				assert
				<<State1 : :COND1() or COND2()>>
				<<Var : :=
  								(State1()) -> 0,
  								(State2()) -> -1,
  								(State3()) -> 9
				>>
			**};
			end Some_Thread.imp;
		\end{lstlisting} 
		& 
		\begin{lstlisting}
			task body Some_Thread
			is
			begin
				loop
					--# assert COND1() or COND2() 
					--#          -> State1();
					--# assert (Var = 0) -> State1() and
					--#        (Var = -1) -> State2() and
					--#        (Var = 9) -> State3();
				end loop;
			end Some_Thread;
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=bless]
			subprogram Some_Subprogram
			features 
				param : out parameter Base_Types::Integer;
			annex subBless
			{**
				pre <<(param > 0)>>
				post <<(param = 0)>>
			**};
			end Some_Subprogram;
		\end{lstlisting} 
		& 
		\begin{lstlisting}
			procedure Some_Subprogram(Param : in out Integer);
		    --# pre Param > 0;
		    --# post Param = 0;
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=bless]
			<<Pre()>>Action()<<Post()>>
		\end{lstlisting} 
		& 
		\begin{lstlisting}
			procedure Action;
			--# pre Pre;
			--# post Post;
		\end{lstlisting} 

		\\ \hline
		

		\begin{lstlisting}[language=bless]
			<<Pre()>>Action()<<Post()>>
		\end{lstlisting} 
		& 
		\begin{lstlisting}
			procedure Action;
			--# pre Pre;
			--# post Post;
		\end{lstlisting} 

		\\ \hline
	\end{longtable}
\end{center}
\doublespacing

Generated (translated) code will not be complete. It will still require Developer's effort to implement missing parts. E.g. when assertion is not defined, it is developer responsibility to implement it.


\section{"DeusEx" translator}
\label{codegen:translator}

The ultimate goal is to perform, translation described in \ref{codegen:mapping} automatically. "DeusEx" translator will enable to perform translation of entire model and parts of the model. Initially, following functions will be supported:
\begin{itemize}
	\item types translation
	\item threads to tasks translation
	\item subprogram to procedure/function translation
	\item single package translation
\end{itemize}

Translator will be created in Scala programming language.

