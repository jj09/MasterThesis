%!TEX root = etdrtemplate.tex
% +--------------------------------------------------------------------+
% | Sample Chapter 4
% +--------------------------------------------------------------------+

\cleardoublepage

% +--------------------------------------------------------------------+
% | Replace "This is Chapter 4" below with the title of your chapter.
% | LaTeX will automatically number the chapters.
% +--------------------------------------------------------------------+

\chapter{AADL/BLESS to SPARK/Ada translation}
\label{codegen}

First step was to create mock (based on doc, aadl models and implemented PCA Pump).
Prototyping Embedded Systems using AADL lasts for a few years \cite{PrototypyingAadl:Paper}.


\section{Extention of exisitng PCA Pump AADL models}
\label{codegen:existing-models}
I added Subprograms etc.
How I did it. Code examples.

\section{AADL/BLESS to SPARK/Ada mapping}
\label{codegen:mapping}
Mapping is driven by Ocarina and "Architecture analysis \& Design Language (AADL) V2 Programming Language Annex Document" \cite{AnnexDoc13}.
Only high level mapping is done. No implementation (thread interactions) like Ocarina does. 

\begin{table}[!ht]
	\caption{AADL to SPARK mapping.}
	\centering
  	\begin{tabular}{ | p{3in} | p{3in} |}
	  	%\multicolumn{1}{c}{\textbf{AADL/BLESS}} & \textbf{SPARK/Ada}\\

		\hline
		\multicolumn{1}{|c|}{\textbf{AADL/BLESS}} & \multicolumn{1}{|c|}{\textbf{SPARK/Ada}} \\ \hline

		\begin{lstlisting}[language=aadl]
			subprogram sp
			features
				e : in parameter T;
				s : out parameter T;
			end sp;
		\end{lstlisting} 
		& 
		\begin{lstlisting}
			procedure sp(e : in T; s : out T) is 
			begin
				null;
			end sp;
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=aadl]
			data Flow_Rate  --dose rate
  				properties
    				BLESS::Typed=>"integer";
    				Data_Model::Base_Type => (classifier(Base_Types::Integer_16));
    				Data_Model::Measurement_Unit => "ml/hr";
			end Flow_Rate;
		\end{lstlisting} 
		& 
		\begin{lstlisting}
			subtype Flow_Rate is Integer range 0 .. Integer'Last;
		\end{lstlisting} 

		\\ \hline
	\end{tabular}
\end{table}

\begin{table}[!ht]
	\caption{BLESS to SPARK contractsmapping.}
	\centering
  	\begin{tabular}{ | p{3in} | p{3in} |}
	  	%\multicolumn{1}{c}{\textbf{AADL/BLESS}} & \textbf{SPARK/Ada}\\

		\hline
		\multicolumn{1}{|c|}{\textbf{AADL/BLESS}} & \multicolumn{1}{|c|}{\textbf{SPARK/Ada}} \\ \hline

		\begin{lstlisting}[language=bless]
			BLESS::Assertion=>"<<VP()>>"
		\end{lstlisting} 
		& 
		\begin{lstlisting}
			--# pre VP;
			--# post VP; 
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=aadl]
			<<Pre()>>Action()<<Post()>>
		\end{lstlisting} 
		& 
		\begin{lstlisting}
			procedure Action;
			--# pre Pre;
			--# post Post;
		\end{lstlisting} 

		\\ \hline
	\end{tabular}
\end{table}

Table, how specific constructs (subset) in AADL/BLESS are translated to SPARK/Ada.

\section{"DeusEx" translator}
\label{codegen:translator}
AADL/BLESS to SPARK/Ada translator in Scala. Main idea.
Maybe at least create base: AADL to AST covertion?

