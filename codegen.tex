%!TEX root = etdrtemplate.tex

\cleardoublepage


\chapter{AADL/BLESS to SPARK Ada translation}
\label{codegen}

First step was to create mock (based on doc, aadl models and implemented PCA Pump).
Prototyping Embedded Systems using AADL lasts for a few years \cite{PrototypyingAadl:Paper}.



\section{AADL/BLESS to SPARK Ada mapping}
\label{codegen:mapping}

%https://wiki.sei.cmu.edu/aadl/images/4/40/13_04_24-AADL-Code_Generation.pdf

%https://wiki.sei.cmu.edu/aadl/images/7/73/AADLV2Overview-AADLUserDay-Feb_2010.pdf (slide 35: port connections)

Mapping is driven by "Architecture analysis \& Design Language (AADL) V2 Programming Language Annex Document" \cite{AnnexDoc}. This document was discussed during AADL User Days in Valencia (February 2013)\footnote{http://www.aadl.info/aadl/downloads/committee/feb2013/presentations/13\_02\_04-AADL-Code\%20Generation.pdf} and in Jacksonville, FL (April 2013)\footnote{https://wiki.sei.cmu.edu/aadl/images/8/8a/Constraint\_Annex\_April22.v3.pdf}. Ocarina tool suite (based on older AADL annex documents \cite{Ocarina:Article}) and its examples\footnote{https://github.com/yoogx/polyorb-hi-ada/tree/master/examples/aadlv2} was also helpful in understanding of AADL to Ada translation.
Only high level mapping is done. No implementation (thread interactions) like Ocarina does. 


\subsection{Data types mapping}
\label{codegen:mapping:data}

One of core AADL packages is \lstinline{Base_Types}. It defined fundamental datatypes for AADL. Its definition is shown on listing \ref{listing:aadl_base_types}.

\singlespacing
\begin{lstlisting}[language=aadl, frame=single, gobble=0, caption={AADL Base\_Types package}, label={listing:aadl_base_types}]
	package Base_Types
	public

	  with Data_Model;

	  data Boolean
	  properties 
	    Data_Model::Data_Representation => Boolean;
	  end Boolean;

	  data Integer
	  properties
	    Data_Model::Data_Representation => Integer;
	  end Integer;

	  -- Signed integer of various byte sizes

	  data Integer_8 extends Integer
	  properties
	    Data_Model::Number_Representation => Signed;
	    Source_Data_Size => 1 Bytes;
	  end Integer_8;

	  data Integer_16 extends Integer
	  properties
	    Data_Model::Number_Representation => Signed;
	    Source_Data_Size => 2 Bytes;
	  end Integer_16;

	  data Integer_32 extends Integer
	  properties
	    Data_Model::Number_Representation => Signed;
	    Source_Data_Size => 4 Bytes;
	  end Integer_32;

	  data Integer_64 extends Integer
	  properties
	    Data_Model::Number_Representation => Signed;
	    Source_Data_Size => 8 Bytes;
	  end Integer_64;

	  -- Unsigned integer of various byte sizes

	  data Unsigned_8 extends Integer
	  properties
	    Data_Model::Number_Representation => Unsigned;
	    Source_Data_Size => 1 Bytes;
	  end Unsigned_8;

	  data Unsigned_16 extends Integer
	  properties
	    Data_Model::Number_Representation => Unsigned;
	    Source_Data_Size => 2 Bytes;
	  end Unsigned_16;

	  data Unsigned_32 extends Integer
	  properties
	    Data_Model::Number_Representation => Unsigned;
	    Source_Data_Size => 4 Bytes;
	  end Unsigned_32;

	  data Unsigned_64 extends Integer
	  properties
	    Data_Model::Number_Representation => Unsigned;
	    Source_Data_Size => 8 Bytes;
	  end Unsigned_64;

	  data Natural extends Integer
	  properties 
	    Data_Model::Integer_Range => 0 .. Max_Target_Integer;
	  end Natural;

	  data Float 
	  properties
	    Data_Model::Data_Representation => Float;
	  end Float;

	  data Float_32 extends Float 
	  properties 
	    Data_Model::IEEE754_Precision => Simple; 
	    Source_Data_Size => 4 Bytes; 
	  end Float_32; 

	  data Float_64 extends Float 
	  properties 
	    Data_Model::IEEE754_Precision => Double; 
	    Source_Data_Size => 8 Bytes; 
	  end Float_64;

	  data Character
	  properties
	    Data_Model::Data_Representation => Character;
	  end Character;

	  data String
	  properties
	    Data_Model::Data_Representation => String;
	  end String;

	end Base_Types;

\end{lstlisting} 
\doublespacing

In Ada 2012, and thus SPARK 2014, there is package \lstinline{Interfaces}, which allows for easy mapping of AADL \lstinline{Base_Types} package. Mapping proposed in Annex Document \cite{AnnexDoc} is presented on listing \ref{listing:aadl2spark2014_base_types_mapping}.

\singlespacing
\begin{lstlisting}[language=aadl, frame=single, gobble=0, caption={Mapping of Base\_Types for SPARK 2014}, label={listing:aadl2spark2014_base_types_mapping}]
	with Interfaces;

	package Base_Types is
		type AADL_Boolean is new Standard.Boolean;
		type AADL_Integer is new Standard.Integer;
	 	type Integer_8 is new Interfaces.Integer_8;
	 	type Integer_16 is new Interfaces.Integer_16;
		type Integer_32 is new Interfaces.Integer_32;
		type Integer_64 is new Interfaces.Integer_64;
		type Unsigned_8 is new Interfaces.Unsigned_8;
		type Unsigned_16 is new Interfaces.Unsigned_16;
		type Unsigned_32 is new Interfaces.Unsigned_32;
		type Unsigned_64 is new Interfaces.Unsigned_64;
		type AADL_Natural is new Standard.Integer; -- XXX incomplete range? 
		type AADL_Float is new Standard.Float;
		type Float_32 is new Interfaces.IEEE_Float_32;
		type Float_64 is new Interfaces.IEEE_Float_64;
	  	type AADL_Character is new Standard.Character;
	end Base_Types;

\end{lstlisting} 
\doublespacing

Mapping for SPARK 2005: Integer, Natural, Boolean already defined in SPARK. Types Float, Character and String are not part of this thesis, because of verification tools limitation. Thus, in this thesis only Integer, Enumeration, Boolean and Record types are analyzed.

Each type is translated into simple type definition and protected type. Then it can be used in multitask programs with Ravescar Profile. For every protected type only setter (\lstinline{Put}) and getter (\lstinline{Get}) subprograms are defined. It can be extended by developer during development phase. 

The default value for priority for each generated type is 10. It can be changed during development phase.

Types: Integer, Boolean and Natural are already defined in SPARK Ada, thus only protected objects are generated for them.

Sample AADL \lstinline{Base_Types} mapping to SPARK Ada is presented in table \ref{table:aadl2spark_types_simple}.

\singlespacing
\begin{center}
	\begin{longtable}{| p{2in} | p{4in} |}
	
		\caption{Base AADL types to SPARK mapping.}
		\label{table:aadl2spark_types_simple}
		\\
		\hline
		\multicolumn{1}{|c|}{\textbf{AADL}} & \multicolumn{1}{|c|}{\textbf{SPARK Ada}} \\ \hline
		\endfirsthead

		\multicolumn{2}{c}%
		{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
		\hline 
		\multicolumn{1}{|c|}{\textbf{AADL}} & \multicolumn{1}{|c|}{\textbf{SPARK Ada}} \\ \hline
		\endhead

		\hline \multicolumn{2}{|r|}{{Continued on next page}} \\ \hline
		\endfoot

		\hline %\hline
		\endlastfoot

		\begin{lstlisting}[language=aadl]
			data Integer
			properties
				Data_Model::Data_Representation => Integer;
			end Integer;
		\end{lstlisting} 
		&
		\begin{lstlisting}[language=ada]
			protected type Integer_Store
		    is
		        pragma Priority (10);

		        function Get return Integer;
		        --# global in Integer_Store;

		        procedure Put(X : in Integer);
		        --# global out Integer_Store;
		        --# derives Integer_Store from X;
		    private
		        TheStoredData : Integer := 0;
		    end Integer_Store;
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=aadl]
			data Integer_16 extends Integer
			properties
				Data_Model::Number_Representation => Signed;
				Source_Data_Size => 2 Bytes;
			end Integer_16;
		\end{lstlisting} 
		&
		\begin{lstlisting}[language=ada]
			type Integer_16 is new Integer range -2**(2*8-1) .. 2**(2*8-1-1);

			protected type Integer_16_Store
		    is
		        pragma Priority (10);

		        function Get return Integer_16;
		        --# global in Integer_16_Store;

		        procedure Put(X : in Integer_16);
		        --# global out Integer_16_Store;
		        --# derives Integer_16_Store from X;
		    private
		        TheStoredData : Integer_16 := 0;
		    end Integer_16_Store;

		    protected body Integer_16_Store is
		        function Get return Integer_16
		        --# global in TheStoredData;
		        is
		        begin
		            return TheStoredData;
		        end Get;

		        procedure Put(X : in Integer_16)
		          --# global out TheStoredData;
		          --# derives TheStoredData from X;
		        is
		        begin
		            TheStoredData := X;
		        end Put;
		    end Integer_16_Store;
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=aadl]
			data Unsigned_16 extends Integer
			properties
				Data_Model::Number_Representation => Unsigned;
				Source_Data_Size => 2 Bytes;
			end Unsigned_16;
		\end{lstlisting} 
		&
		\begin{lstlisting}[language=ada]
			type Unsigned_16 is new Integer range 0 .. 2**(2*8-1);
    
		    protected type Unsigned_16_Store
		    is
		        pragma Priority (10);

		        function Get return Unsigned_16;
		        --# global in Unsigned_16_Store;

		        procedure Put(X : in Unsigned_16);
		        --# global out Unsigned_16_Store;
		        --# derives Unsigned_16_Store from X;
		    private
		        TheStoredData : Unsigned_16 := 0;
		    end Unsigned_16_Store;

		    protected body Unsigned_16_Store is
		        function Get return Unsigned_16
		        --# global in TheStoredData;
		        is
		        begin
		            return TheStoredData;
		        end Get;

		        procedure Put(X : in Unsigned_16)
		          --# global out TheStoredData;
		          --# derives TheStoredData from X;
		        is
		        begin
		            TheStoredData := X;
		        end Put;
		    end Unsigned_16_Store;

		\end{lstlisting}

		\\ \hline

		\begin{lstlisting}[language=aadl]
			data Type_With_Range
				properties
					Data_Model::Data_Representation => Integer;
					Data_Model::Base_Type => (classifier (Base_Types::Unsigned_16));
					Data_Model::Integer_Range => 0 .. 1000;
			end Type_With_Range;
		\end{lstlisting} 
		&
		\begin{lstlisting}[language=ada]
			type Type_With_Range is new Integer range 0 .. 1000;
    
		    protected type Type_With_Range_Store
		    is
		        pragma Priority (10);

		        function Get return Type_With_Range;
		        --# global in Type_With_Range_Store;

		        procedure Put(X : in Type_With_Range);
		        --# global out Type_With_Range_Store;
		        --# derives Type_With_Range_Store from X;
		    private
		        TheStoredData : Type_With_Range := 0;
		    end Unsigned_16_Store;

		    protected body Type_With_Range_Store is
		        function Get return Type_With_Range
		        --# global in TheStoredData;
		        is
		        begin
		            return TheStoredData;
		        end Get;

		        procedure Put(X : in Type_With_Range)
		          --# global out TheStoredData;
		          --# derives TheStoredData from X;
		        is
		        begin
		            TheStoredData := X;
		        end Put;
		    end Type_With_Range_Store;

		\end{lstlisting}
	\end{longtable}
\end{center}
\doublespacing

Type range is defined using AADL properties: \lstinline{Data_Model::Number_Representation}, \lstinline{Source_Data_Size} and \lstinline{Data_Model::Integer_Range}. When \lstinline{Data_Model::Integer_Range} property is not specified, then range is calculated. In case of \lstinline{Integer} representation range starts from negative value, for \lstinline{Unsigned}: from 0. Maximum value for \lstinline{Integer} is calculated using following formula presented on equation \ref{eq:integer_max_formula}. The minimum value formula for Integer (\ref{eq:integer_min_formula}) and maxiumum value for \lstinline{Unsigned} (\ref{eq:unsigned_max_formula}) use similar strategy.

\begin{equation} \label{eq:integer_max_formula}
	Integer\_[Number\_Of\_Bytes*8]\_Max = 2^{\text{Number\_Of\_Bytes} * 8 - 1} - 1
\end{equation}

\begin{equation} \label{eq:integer_min_formula}
	Integer\_[Number\_Of\_Bytes*8]\_Min = -2^{\text{Number\_Of\_Bytes} * 8 - 1}
\end{equation}

\begin{equation} \label{eq:unsigned_max_formula}
	Unsigned\_[Number\_Of\_Bytes*8]\_Max = 2^{\text{Number\_Of\_Bytes} * 8} - 1
\end{equation}

Mapping for enumeration types is presented on table \ref{table:aadl2spark_types_enums}. BLESS properties are ignored in translation.

\singlespacing
\begin{center}
	\begin{longtable}{| p{3in} | p{3in} |}
	
		\caption{AADL/BLESS enumeration types to SPARK mapping.}
		\label{table:aadl2spark_types_enums}
		\\
		\hline
		\multicolumn{1}{|c|}{\textbf{AADL}} & \multicolumn{1}{|c|}{\textbf{SPARK Ada}} \\ \hline
		\endfirsthead

		\multicolumn{2}{c}%
		{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
		\hline 
		\multicolumn{1}{|c|}{\textbf{AADL}} & \multicolumn{1}{|c|}{\textbf{SPARK Ada}} \\ \hline
		\endhead

		\hline \multicolumn{2}{|r|}{{Continued on next page}} \\ \hline
		\endfoot

		\hline %\hline
		\endlastfoot

		\begin{lstlisting}[language=aadl]
			data Enum_Type
				properties	
					BLESS::Typed=>"enumeration (Enumerator1, Enumerator2, Enumerator3)";
					Data_Model::Data_Representation => Enum;
					Data_Model::Enumerators => ("Enumerator1", "Enumerator2", "Enumerator3");
			end Enum_Type; 
		\end{lstlisting} 
		&
		\begin{lstlisting}[language=ada]
			type Enum_Type is (Enumerator1, Enumerator2, Enumerator3);

			protected type Enum_Type_Store
		    is
		        pragma Priority (10);

		        function Get return Enum_Type;
		        --# global in Enum_Type_Store;

		        procedure Put(X : in Enum_Type);
		        --# global out Enum_Type_Store;
		        --# derives Enum_Type_Store from X;
		    private
		        TheStoredData : Enum_Type := Enum_Type'First;
		    end Enum_Type_Store;

		    protected body Enum_Type_Store is
		        function Get return Enum_Type
		        --# global in TheStoredData;
		        is
		        begin
		            return TheStoredData;
		        end Get;

		        procedure Put(X : in Enum_Type)
		          --# global out TheStoredData;
		          --# derives TheStoredData from X;
		        is
		        begin
		            TheStoredData := X;
		        end Put;
		    end Enum_Type_Store;
		\end{lstlisting} 
			
	\end{longtable}
\end{center}
\doublespacing

Sometimes it is pragmatic to define a type, which has exactly the same range like some already existing type. Especially when it is used for some specific calculations. E.g. measuring the speed. Let's say, that \lstinline{Unsigned_16} was used. Then, during development of new car model, it is not enough. In case when e.g. \lstinline{Speed_Type} is not defined, there are two options. First: change definition (range) of \lstinline{Unsigned_16}. That is bad choice, especially because its name specify the range. Another reason: it might be used not only for measuring the Speed, but maybe also for fuel level, which range is still fine. Second option is to change \lstinline{Unsigned_16} to e.g. \lstinline{Unsigned_32} everywhere in Speed Control Module (and maybe also in some external modules). When \lstinline{Speed_Type} is defined and used everywhere for speed units, then only definition of \lstinline{Speed_Type} has to be changed. To define type, using exising type in AADL \lstinline{Data_Model::Base_Type} property is used. Translation to SPARK Ada is shown in \ref{table:aadl2spark_types_subtypes}. 

\singlespacing
\begin{center}
	\begin{longtable}{| p{3in} | p{3in} |}
	
		\caption{AADL types to SPARK mapping: Subtypes.}
		\label{table:aadl2spark_types_subtypes}
		\\
		\hline
		\multicolumn{1}{|c|}{\textbf{AADL}} & \multicolumn{1}{|c|}{\textbf{SPARK Ada}} \\ \hline
		\endfirsthead

		\multicolumn{2}{c}%
		{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
		\hline 
		\multicolumn{1}{|c|}{\textbf{AADL}} & \multicolumn{1}{|c|}{\textbf{SPARK Ada}} \\ \hline
		\endhead

		\hline \multicolumn{2}{|r|}{{Continued on next page}} \\ \hline
		\endfoot

		\hline %\hline
		\endlastfoot

		\begin{lstlisting}[language=aadl]
			data Speed_Type
			 	properties
			 		BLESS::Typed=>"integer";
				    Data_Model::Base_Type => (classifier(Base_Types::Unsigned_16));
			end Speed_Type;
		\end{lstlisting} 
		&
		\begin{lstlisting}[language=ada]
			subtype Speed_Type is Base_Types.Unsigned_16;
		\end{lstlisting} 

		\\
		\hline

		\begin{lstlisting}[language=aadl]
			data Speed_Type extends Base_Types::Integer
			end Speed_Type;
		\end{lstlisting} 
		&
		\begin{lstlisting}[language=ada]
			type Speed_Type is new Base_Types.Integer;
		\end{lstlisting} 
			
	\end{longtable}
\end{center}
\doublespacing

Using property \lstinline{Data_Model::Data_Representation} array type in AADL can be defined. In addition to that, size fo array has to be specified by \lstinline{Data_Model::Dimension} property. Sample mapping of array of 10 integers is shown in table \ref{table:aadl2spark_types_arrays}.

\singlespacing
\begin{center}
	\begin{longtable}{| p{3in} | p{3in} |}
	
		\caption{AADL arrays to SPARK mapping.}
		\label{table:aadl2spark_types_arrays}
		\\
		\hline
		\multicolumn{1}{|c|}{\textbf{AADL}} & \multicolumn{1}{|c|}{\textbf{SPARK Ada}} \\ \hline
		\endfirsthead

		\multicolumn{2}{c}%
		{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
		\hline 
		\multicolumn{1}{|c|}{\textbf{AADL}} & \multicolumn{1}{|c|}{\textbf{SPARK Ada}} \\ \hline
		\endhead

		\hline \multicolumn{2}{|r|}{{Continued on next page}} \\ \hline
		\endfoot

		\hline %\hline
		\endlastfoot

		\begin{lstlisting}[language=aadl]
			data Some_Array
			  	properties
			  		BLESS::Typed => "array [10] of Base_Types::Integer_32";
				    Data_Model::Data_Representation => Array;
				    Data_Model::Base_Type => (classifier(Base_Types::Integer_32));
				    Data_Model::Dimension => (10);
			end Some_Array;
		\end{lstlisting} 
		&
		\begin{lstlisting}[language=ada]
			subtype Some_Array_Index is Integer range 1 .. 10;
    		type Some_Array is array (Some_Array_Index) of Base_Types.Integer_32;

    		protected type Some_Array_Store
		    is
		        pragma Priority (10);

		        function Get(Ind : in Integer) return Base_Types.Integer_32;
		        --# global in Some_Array_Store;

		        procedure Put(Ind : in Integer; Val : in Base_Types.Integer_32);
		        --# global in out Some_Array_Store;
		        --# derives Some_Array_Store from Some_Array_Store, Ind, Val;
		    private
		        TheStoredData : Some_Array := Some_Array'(others => 0);
		    end Some_Array_Store;

		    protected body Some_Array_Store
		    is
		        function Get(Ind : in Integer) return Base_Types.Integer_32
		        --# global in TheStoredData;
		        is
		        begin
		            return TheStoredData(Ind);
		        end Get;

		        procedure Put(Ind : in Integer; Val : in Base_Types.Integer_32)
		          --# global in out TheStoredData;
		          --# derives TheStoredData from TheStoredData, Ind, Val;
		        is
		        begin
		            TheStoredData(Ind) := Val;
		        end Put;
		    end Some_Array_Store;
		\end{lstlisting} 
			
	\end{longtable}
\end{center}
\doublespacing

AADL v2 allows to create struct data types, using \lstinline{Data_Model::Data_Representation => Struct}. AADL Struct is mapped to SPARK Ada record type. The mapping is presented in table \ref{table:aadl2spark_types_records}.

\singlespacing
\begin{center}
	\begin{longtable}{| p{3in} | p{3in} |}
	
		\caption{AADL structs to SPARK Ada records mapping.}
		\label{table:aadl2spark_types_records}
		\\
		\hline
		\multicolumn{1}{|c|}{\textbf{AADL}} & \multicolumn{1}{|c|}{\textbf{SPARK Ada}} \\ \hline
		\endfirsthead

		\multicolumn{2}{c}%
		{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
		\hline 
		\multicolumn{1}{|c|}{\textbf{AADL}} & \multicolumn{1}{|c|}{\textbf{SPARK Ada}} \\ \hline
		\endhead

		\hline \multicolumn{2}{|r|}{{Continued on next page}} \\ \hline
		\endfoot

		\hline %\hline
		\endlastfoot

		\begin{lstlisting}[language=aadl]
			data Some_Record_Type
				properties
					BLESS::Typed => "record (
						Field1 : Base_Types::Integer_32;  
						Field2 : Base_Types::Boolean;  
						Field3 : Base_Types::Unsigned_32;  
						);
					Data_Model::Data_Representation => Struct;
					Data_Model::Element_Names => ("Field1", "Field2", "Field3");
					Data_Model::Base_Type => 
					( 
						classifier(Base_Types::Integer_32), 			    
						classifier(Base_Types::Boolean),
						classifier(Base_Types::Unsigned_32)
					);      
			end Some_Record_Type;  
		\end{lstlisting} 
		&
		\begin{lstlisting}[language=ada]
			type Some_Record_Type is record
		        Field1 : Integer_32;
		        Field2 : Boolean;
		        Field3 : Unsigned_32;
		    end record;
		\end{lstlisting} 
			
	\end{longtable}
\end{center}
\doublespacing

During AADL/BLESS to SPARK Ada types mapping, SPARK Examiner was helpful. Eg. it detected redundancy in enumerators. Both \lstinline{Alarm_Type} and \lstinline{Warning_Type} contained \lstinline{No_Alarm} enumerators, which was a bug. \lstinline{Warning_Type} should have \lstinline{No_Warning} enumerator instead.


\subsection{AADL ports mapping}
\label{codegen:mapping:ports}

Proposed ports mapping shown in table \ref{table:aadl2spark_ports} is based on AADL runtime services from Annex 2 to "Programming Language Annex Document" \cite{AnnexDoc}. Additionaly, the mapping contains SPARK 2005 contracts. Data types used by ports has to be defined earlier. Moreover, for port communication, protected types are used. To enable concurrency.

% maybe split right column into 2 rows: spec and body?
\singlespacing
\begin{center}
	\begin{longtable}{| p{2in} | p{4in} |}
	
		\caption{AADL to SPARK ports mapping.}
		\label{table:aadl2spark_ports}
		\\
		\hline
		\multicolumn{1}{|c|}{\textbf{AADL/BLESS}} & \multicolumn{1}{|c|}{\textbf{SPARK Ada}} \\ \hline
		\endfirsthead

		\multicolumn{2}{c}%
		{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
		\hline 
		\multicolumn{1}{|c|}{\textbf{AADL/BLESS}} & \multicolumn{1}{|c|}{\textbf{SPARK Ada}} \\ \hline
		\endhead

		\hline \multicolumn{2}{|r|}{{Continued on next page}} \\ \hline
		\endfoot

		\hline %\hline
		\endlastfoot

		\begin{lstlisting}[language=aadl]
			Port_Name : 
				in data port Port_Type;
		\end{lstlisting} 
		&
		\begin{lstlisting}[language=ada]
			-- spec (.ads):
			--# own protected Port_Name : Port_Type_Store(Priority => 10)

			procedure Receive_Port_Name;
			--# global out Port_Name;

			-- body (.adb):
			Port_Name : Port_Type_Store;

			procedure Receive_Port_Name 
			is
			begin
				-- TODO: implement receiving Port_Name value
				-- e.g.:
				-- Port_Name.Put(Some_Pkg.Get_Port_Name);
			end Receive_Port_Name;
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=aadl]
			Port_Name : 
				out data port Port_Type;
		\end{lstlisting} 
		&
		\begin{lstlisting}[language=ada]
			-- spec (.ads)
			--# own protected Port_Name : Port_Type_Store(Priority => 10)
			
			procedure Get_Port_Name(Port_Name_Out : out Port_Type);
			--# global in Port_Name;
			--# derives Port_Name_Out from Port_Name;

			-- body (.adb):
			Port_Name : Port_Type_Store;

			procedure Get_Port_Name(Port_Name_Out : out Port_Type)
			is
			begin
				Port_Name_Out := Port_Name.Get;
			end Get_Port_Name;
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=aadl]
			Port_Name : 
				in event port;
		\end{lstlisting} 
		&
		\begin{lstlisting}[language=ada]
			-- spec (.ads)
			procedure Put_Port_Name;

			-- body (.adb):
			procedure Put_Port_Name 
			is
			begin
				-- TODO: implement event handler
			end Put_Port_Name;
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=aadl]
			Port_Name : 
				out event port;
		\end{lstlisting} 
		&
		\begin{lstlisting}[language=ada]
			-- spec (.ads)
			procedure Send_Port_Name;

			-- body (.adb):

			procedure Send_Port_Name 
			is
			begin
				-- TODO: implement receiving Port_Name value
				-- e.g.:
				-- Some_Pkg.Put_Port_Name;
			end Send_Port_Name;
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=aadl]
			Port_Name : 
				in event data port Port_Type;
		\end{lstlisting} 
		&
		\begin{lstlisting}[language=ada]
			-- spec (.ads)
			--# own protected Port_Name : Port_Type_Store(Priority => 10);

			procedure Put_Port_Name(Port_Name_In : Port_Type);
			--# global out Port_Name;
			--# derives Port_Name from Port_Name_In;

			-- body (.adb):
			Port_Name : Port_Type_Store;

			procedure Put_Port_Name (Port_Name_In : Port_Type) 
			is
			begin
				Port_Name.Put(Port_Name_In);
			end Put_Port_Name;
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=aadl]
			Port_Name : 
				out event data port Port_Type;
		\end{lstlisting} 
		&
		\begin{lstlisting}[language=ada]
			-- spec (.ads)
			--# own protected Port_Name : Port_Type_Store(Priority => 10);
			
			procedure Send_Port_Name;
    		--# global in Port_Name;

			-- body (.adb):
			Port_Name : Port_Type_Store;

			procedure Send_Port_Name 
			is
			begin
				-- TODO: implement receiving Port_Name value
				-- e.g.:
				-- Some_Pkg.Put_Port_Name(Port_Name);
			end Send_Port_Name;
		\end{lstlisting} 
	\end{longtable}
\end{center}
\doublespacing

There is a problem: "consumer.ads:1:13: Semantic Error 135 - The package Producer is undeclared or not visible, or there is a circularity in the list of inherited packages.".


\subsection{Thread to task mapping}
\label{codegen:mapping:threads}

AADL Threads are mapped into SPARK Ada tasks according to table \ref{table:threads2tasks}.

\singlespacing
\begin{table}[!ht]
	\caption{AADL threads to SPARK Ada tasks mapping.}
	\label{table:threads2tasks}
	\centering
  	\begin{tabular}{ | p{3.5in} | p{2.5in} |}
	  	%\multicolumn{1}{c}{\textbf{AADL/BLESS}} & \textbf{SPARK Ada}\\

		\hline
		\multicolumn{1}{|c|}{\textbf{AADL/BLESS}} & \multicolumn{1}{|c|}{\textbf{SPARK Ada}} \\ \hline

		\begin{lstlisting}[language=aadl]
			package Some_Pkg
				thread Some_Thread
					features
						Some_Port : out data port Port_Type;
				end Some_Thread;
			end Some_Pkg;
		\end{lstlisting} 
		& 
		\begin{lstlisting}
			package Some_Pkg
			is
				task type Some_Thread
				--# global out Some_Port;
				is
					pragma Priority(10);
				end Some_Thread;
			end Some_Pkg;
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=aadl]
			package Some_Pkg
				thread Some_Thread.imp
				end Some_Thread;
			end Some_Pkg;
		\end{lstlisting} 
		& 
		\begin{lstlisting}
			package body Custom_Pkg
			is
				st : Some_Thread;

				task body Some_Thread
				is
				begin
					loop
						-- implementation
					end loop;
				end Some_Thread;
			end Custom_Pkg;
		\end{lstlisting} 

		\\ \hline
	\end{tabular}
\end{table}
\doublespacing


\subsection{Subprograms mapping}
\label{codegen:mapping:subprograms}

\singlespacing
\begin{table}[!ht]
	\caption{AADL subprograms to SPARK Ada subprograms(procedures/functions) mapping.}
	\label{table:subprograms_mapping}
	\centering
  	\begin{tabular}{ | p{3in} | p{3in} |}
	  	%\multicolumn{1}{c}{\textbf{AADL/BLESS}} & \textbf{SPARK Ada}\\

		\hline
		\multicolumn{1}{|c|}{\textbf{AADL/BLESS}} & \multicolumn{1}{|c|}{\textbf{SPARK Ada}} \\ \hline

		\begin{lstlisting}[language=aadl]
			subprogram sp
			features
				e : in parameter T;
				s : out parameter T;
			end sp;
		\end{lstlisting} 
		& 
		\begin{lstlisting}
			procedure sp(e : in T; s : out T) is 
			begin
				--# implementation
			end sp;
		\end{lstlisting} 		

		\\ \hline
	\end{tabular}
\end{table}
\doublespacing


\subsection{Feature groups mapping}
\label{codegen:mapping:feature_groups}

In SPARK Ada there are nested packages and child packages. Sample nested packages are shown in listing \ref{lst:nested_packages}. Equivalent child packages are shown in listing \ref{lst:child_packages}. The name of a child package consists of the parent unit's name followed by the child package's identifier, separated by a period (dot) `.'. Calling convention is the same for child and nested packages (e.g. \lstinline{P.N} in listings \ref{lst:nested_packages} and \ref{lst:child_packages}. However, there is a difference between nested packages and child packages. In nested package declarations become visible as they are introduced, in textual order. For example, in listing \ref{lst:nested_packages} spec \lstinline{N} cannot refer to \lstinline{M} in any way. In case of child packages, with certain exceptions, all the functionality of the parent is available to a child and parent can access all its child packages. More precisely: all public and private declarations of the parent package are visible to all child packages. Private child package can be accessed only from parent's body.

\singlespacing
\begin{lstlisting}[language=ada, frame=single, gobble=0, caption={Nested packages in SPARK Ada}, label={lst:nested_packages}]
	package P is
	   D: Integer;

	   --  a nested package:
	   package N is
	      X: Integer;
	   private
	      Foo: Integer;
	   end N;

	   E: Integer;
	private
	   --  nested package in private section:
	   package M is
	      Y: Integer;
	   private
	      Bar: Integer;
	   end M;

	end P;
\end{lstlisting}
\doublespacing

\singlespacing
\begin{lstlisting}[language=ada, frame=single, gobble=0, caption={Child packages in SPARK Ada}, label={lst:child_packages}]
	package P is
	   D: Integer;
	   E: Integer;
	end P;

	--  a child package:
	package P.N is
      X: Integer;
   	private
      Foo: Integer;
	end P.N;

	--  a child private package:
	private package M is
	  Y: Integer;
	private
	  Bar: Integer;
	end M;
\end{lstlisting}
\doublespacing

There was an idea to create child package to encapsulate one feature group in it. However, SPARK Ada does not allow to access child packages private part from parent. That will require to expose feature group internal variable, which will have to be acceessible globaly. It is definitely not good solution. Thus, feature group is translated with prefix \lstinline{Feature_Group_Name_*}.



\subsection{AADL package to SPARK Ada package mapping}
\label{codegen:mapping:packages}

On listing \ref{lst:aadl_sample}, there is shown sample AADL package with system. It contains all types of ports and feature group.

\singlespacing
\begin{lstlisting}[language=aadl, frame=single, gobble=0, caption={Sample AADL package with system}, label={lst:aadl_sample}]
	package Some_Pkg
	public
	with Base_Types;

	feature group Some_Features
	features
	  Some_Out_Port: out data port Base_Types::Integer;
	  Some_In_Port: in data port Base_Types::Integer;
	end Some_Features;

	system Some_System
	features
	  Some_Feature_Group : feature group Some_Features;
	  
	  In_Data_Port : in data port Base_Types::Integer;
	  Out_Data_Port : out data port Base_Types::Integer;
	  In_Event_Port : in event port;
	  Out_Event_Port : out event port;
	  In_Event_Data_Port : in event data port Base_Types::Integer;
	  Out_Event_Data_Port : out event data port Base_Types::Integer;
	end Some_System;

	end Some_Pkg;
\end{lstlisting}
\doublespacing

Based on ports mapping, presented in section \ref{codegen:mapping:ports}, translation to SPARK Ada package is shown in listing \ref{lst:package_mapping}. 

\singlespacing
\begin{lstlisting}[language=ada, frame=single, gobble=0, caption={Translation of sample AADL package from listing \ref{lst:aadl_sample}}, label={lst:package_mapping}]
	package Some_Pkg
	--# own Some_Features_Some_Out_Port : Integer;
	--#     Some_Features_Some_In_Port : Integer;
	--#     In_Data_Port : Integer;
	--#     Out_Data_Port : Integer;
	--#     In_Event_Data_Port : Integer;
	--#     Out_Event_Data_Port : Integer;
	--# initializes Some_Features_Some_Out_Port,
	--#             Some_Features_Some_In_Port,
	--#             In_Data_Port,
	--#             Out_Data_Port,
	--#             In_Event_Data_Port,
	--#             Out_Event_Data_Port;
	is

	    function Some_Features_Get_Some_Out_Port return Integer;
	    --# global in Some_Features_Some_Out_Port;

	    procedure Some_Features_Receive_Some_In_Port;
	    --# global out Some_Features_Some_In_Port;

	    procedure Receive_In_Data_Port;
	    --# global out In_Data_Port;

	    function Get_Out_Data_Port return Integer;
	    --# global in Out_Data_Port;

	    procedure Put_In_Event_Port;

	    procedure Send_Out_Event_Port;

	    procedure Put_In_Event_Data_Port(In_Event_Data_Port_In : Integer);
	    --# global out In_Event_Data_Port;
	    --# derives In_Event_Data_Port from In_Event_Data_Port_In;

	    procedure Send_Out_Event_Data_Port;
	    --# global in Out_Event_Data_Port;

	end Some_Pkg;

	package body Some_Pkg
	is
	    Some_Features_Some_Out_Port : Integer := 0;
	    Some_Features_Some_In_Port : Integer := 0;
	    In_Data_Port : Integer := 0;
	    Out_Data_Port : Integer := 0;
	    In_Event_Data_Port : Integer := 0;
	    Out_Event_Data_Port : Integer := 0;

	    function Some_Features_Get_Some_Out_Port return Integer
	    is
	    begin
	        return Some_Features_Some_Out_Port;
	    end Some_Features_Get_Some_Out_Port;

	    procedure Some_Features_Receive_Some_In_Port
	    is
	    begin
	        -- implementation
	    end Some_Features_Receive_Some_In_Port;

	    procedure Receive_In_Data_Port
	    is
	    begin
	        -- implementation
	    end Receive_In_Data_Port;

	    function Get_Out_Data_Port return Integer
	    is
	    begin
	        return Out_Data_Port;
	    end Get_Out_Data_Port;

	    procedure Put_In_Event_Port
	    is
	    begin
	        -- implementation
	    end Put_In_Event_Port;

	    procedure Send_Out_Event_Port
	    is
	    begin
	        -- implementation
	    end Send_Out_Event_Port;

	    procedure Put_In_Event_Data_Port(In_Event_Data_Port_In : Integer)
	    is
	    begin
	        In_Event_Data_Port := In_Event_Data_Port_In;
	    end Put_In_Event_Data_Port;

	    procedure Send_Out_Event_Data_Port
	    is
	    begin
	        -- implementation
	    end Send_Out_Event_Data_Port;

	end Some_Pkg;
\end{lstlisting}
\doublespacing



\subsection{AADL property set to SPARK Ada package mapping}
\label{codegen:mapping:propertyset}

There is no equivalent construct for AADL property set in SPARK Ada. In this thesis only properties of type \lstinline{constant aadlinteger} are considered. There are issues with using non-constant in SPARK Ada package (e.g. when using them in some type definition).

Table \ref{table:propertyset_mapping} shows sample property set mapping to SPARK Ada package.

\singlespacing
\begin{table}[!ht]
	\caption{AADL property set to SPARK Ada package mapping.}
	\label{table:propertyset_mapping}
	\centering
  	\begin{tabular}{ | p{3in} | p{3in} |}

		\hline
		\multicolumn{1}{|c|}{\textbf{AADL}} & \multicolumn{1}{|c|}{\textbf{SPARK Ada}} \\ \hline

		\begin{lstlisting}[language=aadl]
			property set Some_Properties is
				Some_Property1 : constant aadlinteger => 10;
				Some_Property2 : constant aadlinteger => 27 applies to (all);
				Some_Property3 : constant aadlinteger => Some_Properties::Some_Property1 applies to (all);
			end Some_Properties;
		\end{lstlisting} 
		& 
		\begin{lstlisting}
			package Some_Properties
			is
				Some_Property1 : constant Integer := 10;
				Some_Property2 : constant Integer := 27;
				Some_Property3 : constant Integer := Some_Property1;
			end Some_Properties;
		\end{lstlisting} 		

		\\ \hline
	\end{tabular}
\end{table}
\doublespacing

In AADL, all declarations must have an \lstinline{applies to} clause. It is ignored in above translation scheme.


\subsection{BLESS mapping}
\label{codegen:mapping:bless}

\singlespacing
\begin{center}
	\begin{longtable}{| p{3in} | p{3in} |}
		\caption{BLESS to SPARK contracts mapping.}
		\label{table:bless2spark}
		\\
		\hline
		\multicolumn{1}{|c|}{\textbf{AADL/BLESS}} & \multicolumn{1}{|c|}{\textbf{SPARK Ada}} \\ \hline
		\endfirsthead

		\multicolumn{2}{c}%
		{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
		\hline 
		\multicolumn{1}{|c|}{\textbf{AADL/BLESS}} & \multicolumn{1}{|c|}{\textbf{SPARK Ada}} \\ \hline
		\endhead

		\hline \multicolumn{2}{|r|}{{Continued on next page}} \\ \hline
		\endfoot

		\hline %\hline
		\endlastfoot

		\begin{lstlisting}[language=bless]
			BLESS::Assertion=>"<<COND1()>>"
		\end{lstlisting} 
		& 
		\begin{lstlisting}
			--# assert COND1;
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=bless]
			thread Some_Thread
			features
				Some_Port : out event port
				{BLESS:Assertion => "<<(Var1 < Var2 and COND2())>>";};
			end Some_Thread;
		\end{lstlisting} 
		& 
		\begin{lstlisting}
			task body Some_Thread
			is
			begin
				loop
					--# assert (Var1 < Var2 and COND2);
				end loop;
			end Some_Thread;
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=bless]
			thread implementation Some_Thread.imp
			annex BLESS 
			{**
				invariant <<(Some_Var < Other_Var)>>
			**};
			end Some_Thread.imp;
		\end{lstlisting} 
		& 
		\begin{lstlisting}
			task body Some_Thread
			is
			begin
				loop
					--# assert (Some_Var < Other_Var);
				end loop;
			end Some_Thread;
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=bless]
			thread implementation Some_Thread.imp
			annex BLESS 
			{**
				assert
				<<State1 : :COND1() or COND2()>>
				<<Var : :=
  								(State1()) -> 0,
  								(State2()) -> -1,
  								(State3()) -> 9
				>>
			**};
			end Some_Thread.imp;
		\end{lstlisting} 
		& 
		\begin{lstlisting}
			task body Some_Thread
			is
			begin
				loop
					--# assert (COND1 or COND2)
					--#          -> State1();
					--# assert (Var = 0) -> State1 and
					--#        (Var = -1) -> State2 and
					--#        (Var = 9) -> State3;
				end loop;
			end Some_Thread;
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=bless]
			subprogram Some_Subprogram
			features 
				param : out parameter Base_Types::Integer;
			annex subBless
			{**
				pre <<(param > 0)>>
				post <<(param = 0)>>
			**};
			end Some_Subprogram;
		\end{lstlisting} 
		& 
		\begin{lstlisting}
			procedure Some_Subprogram(Param : in out Integer);
		    --# pre Param > 0;
		    --# post Param = 0;
		\end{lstlisting} 

		\\ \hline

		\begin{lstlisting}[language=bless]
			<<Pre()>>Action()<<Post()>>
		\end{lstlisting} 
		& 
		\begin{lstlisting}
			procedure Action;
			--# pre Pre;
			--# post Post;
		\end{lstlisting} 

		\\ \hline
		

		\begin{lstlisting}[language=bless]
			<<Pre()>>Action()<<Post()>>
		\end{lstlisting} 
		& 
		\begin{lstlisting}
			procedure Action;
			--# pre Pre;
			--# post Post;
		\end{lstlisting} 

		\\ \hline
	\end{longtable}
\end{center}
\doublespacing

Generated (translated) code will not be complete. It will still require Developer's effort to implement missing parts. E.g. when assertion is not defined, it is developer responsibility to implement it.



\section{Port communication}

System has process(es), process has threads. For sample ports mapping, ports are exposed using \lstinline{system}. Communication between two systems has to be described by another system. Figure \ref{figure:port_communication} presents communication between two systems: panel and pump. [DESCRIBE]

\begin{figure}[ht]%t=top, b=bottom, h=here
    \begin{center}
    	\includegraphics[height=2.5in]{figures/port-communication.png}
    	\caption{Example of port communication}
    \end{center}
    \label{figure:port_communication}
\end{figure}

[Port\_Communication code]


\section{"DeusEx" translator}
\label{codegen:translator}

The ultimate goal is to perform, translation described in \ref{codegen:mapping} automatically. "DeusEx" translator will enable to perform translation of entire model and parts of the model. Initially, following functions will be supported:
\begin{itemize}
	\item types translation
	\item threads to tasks translation
	\item subprogram to procedure/function translation
	\item single package translation
\end{itemize}

Translator will be created in Scala programming language.

